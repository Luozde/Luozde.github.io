<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题Java整理]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%9D%A2%E8%AF%95%E9%A2%98Java%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本部分主要是设计Java SE 部分的核心面试知识，持续更新… Java面试题整理1、设计模式1.1 简述一下你了解的设计模式。答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 接下来我用一个实例来对代理模式进行更深一步的介绍。a. 实例概况(方法增强) 背景：小成希望买一台最新的顶配Mac电脑冲突：国内还没上，只有美国才有解决方案：寻找代购进行购买代购（代理对象） 代替 我（真实对象） 去买Mac（间接访问的操作） b. 使用步骤步骤1： 创建抽象对象接口（Subject）：声明你（真实对象）需要让代购（代理对象）帮忙做的事（买Mac） 123public interface Subject &#123; public void buyMac();&#125; 步骤2： 创建真实对象类（RealSubject）,即”我“ 123456public class RealSubject implement Subject&#123; @Override public void buyMac() &#123; System.out.println(”买一台Mac“); &#125; &#125; 步骤3： 创建代理对象类（Proxy），即”代购“，并通过代理类创建真实对象实例并访问其方法 12345678910111213141516public class Proxy implements Subject&#123; @Override public void buyMac&#123; //引用并创建真实对象实例，即”我“ RealSubject realSubject = new RealSubject()； //调用真实对象的方法，进行代理购买Mac realSubject.buyMac（）； //代理对象额外做的操作 this.WrapMac()； &#125; public void WrapMac()&#123; System.out.println(”用盒子包装好Mac“); &#125;&#125; 步骤4： 客户端调用 123456public class ProxyPattern &#123; public static void main(String[] args)&#123; Subject proxy = new Proxy()； proxy.buyMac()； &#125;&#125; 结果输出 买一台Mac 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 ​ 适配器模式例子：电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 单例设计模式 解决的问题：保证一个类在内存中的对象唯一性。 比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。 Runtime()**方法就是单例设计模式进行设计的。** 如何保证对象唯一性呢？ 思想： 1，不让其他程序创建该类对象。 2，在本类中创建一个本类对象。 3，对外提供方法，让其他程序获取这个对象。 步骤： 1、因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象； 2、就在类中创建一个本类的对象； 3、定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控） 代码体现： 1，私有化构造函数； 2，创建私有并静态的本类对象； 3，定义公有并静态的方法，返回该对象。 123456789//饿汉式class Single&#123; private Single()&#123;&#125; //**私有化构造函数。** private static Single s = new Single(); //**创建私有并静态的本类对象。** public static Single getInstance()&#123; //**定义公有并静态的方法，返回该对象。** return s; &#125;&#125; 1234567891011//懒汉式:延迟加载方式。class Single2&#123; private Single2()&#123;&#125; private static Single2 s = null; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 1.2 在Java中，什么时候用重载，什么时候用重写？对有经验的Java设计师来说，这是一个相当简单的问题。如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在Java中，重载的方法签名不同，而重写并不是。 1.3 你可以说出几个在JDK库中使用的设计模式吗？装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于Swing和很多的事件监听中。 1.4 MVC是什么？MVC是Model-View-Controller(模型-视图-控制器)的缩写，是一种混合设计模式。用到这种设计模式时，我们所创建的对象要分为：Model 对象，View对象和Controller对象。 归类依据是： Model对象：负责存储数据以及定义如何操作这些数据。 View对象：负责展示而且允许用户编辑来自应用程序的Model对象，View对象用来构建用户界面，与用户交互。 Controller对象：是Model对象与View对象的中间人，负责传递数据，监听各种事件，管理其他对象的生命周期等。 图片来自《iOS编程》(第4版)，作者：【美】Christian Keur Aaron HillegassJoe Conway 上图显示的是应用程序响应用户操作的一个流程。 打个比方：Controller对象好像是一家销售公司，Model对象是产品提供者，View对象是销售人员。公司卖什么，销售人员不用管，销售人员是谁，产品提供者也无需管，公司管要卖什么，管让哪个销售人员去卖。这样一来，各个部分都做自己最擅长的事情，出问题了直接找对应环节，避免了混乱。产品提供者也可以提供产品给其他公司，销售人员换个公司照样能做销售，公司也可以找其他产品提供者，聘用其他销售人员，互相都弱依赖，谁离了谁都能活（当然了，这只是一种理想状态，现实生活中有很多离开了某某某就失业就破产的人和公司）。 再看MVC设计模式，Model对象负责数据，很显然，这里的数据不仅仅可以用于某一个应用，View对象也可以直接拿到其他应用中去，Controller对象就更不用说了。实际上，苹果就是这样封装的：比如UIButton，封装了ImageView和Lable，ImageView显示什么图片，Lable显示什么文字，这些不用UIButton管，它只知道自己可以显示一张图片和一段文字以及与用户交互，其他的交给外界，你给啥图片我显示什么图片，你给啥文字我显示什么文字。这样，UIButton才可以重复使用。 综上，MVC设计模式解决了对象间耦合问题，使得程序易于复用、扩展和变更。 作者：习吾学 链接：https://www.jianshu.com/p/254e2478a4ca 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 2、接口问题2.1 举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？这是很常用但又是很难回答的设计面试问题。接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题： 在Java中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。 接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable等等，因此当你使用抽象类来表示行为时，你的类就不能同时是Runnable和Clonable(译者注：这里的意思是指如果把Runnable等实现为抽象类的情况)，因为在Java中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。 在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。 如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。 3、集合框架3.1 集合与数组数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。 集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。 3.2 层次关系如图所示：图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口 Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。 3.3 几种重要的接口和类简介1、List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 2、Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 3、Map（键值对、键唯一、值不唯一） Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 作者：心诚则灵–艾来源：CSDN原文：https://blog.csdn.net/u010775025/article/details/79315361版权声明：本文为博主原创文章，转载请附上博文链接！ 3.4 ArrayList和Vector的区别（是否有序、是否重复、数据结构、底层实现）ArrayList和Vector都实现了List接口，他们都是有序集合，并且存放的元素是允许重复的。它们的底层都是通过数组来实现的，因此列表这种数据结构检索数据速度快，但增删改速度慢。 而ArrayList和Vector的区别主要在两个方面： 第一，线程安全。Vector是线程安全的，而ArrayList是线程不安全的。因此在如果集合数据只有单线程访问，那么使用ArrayList可以提高效率。而如果有多线程访问你的集合数据，那么就必须要用Vector，因为要保证数据安全。 第二，数据增长。ArrayList和Vector都有一个初始的容量大小，当存储进它们里面的元素超过了容量时，就需要增加它们的存储容量。ArrayList每次增长原来的0.5倍，而Vector增长原来的一倍。ArrayList和Vector都可以设置初始空间的大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 3.5 HashMap和Hashtable的区别HashMap和Hashtable都实现了Map接口，并且都是key-value的数据结构。它们的不同点主要在三个方面： 第一，Hashtable是Java1.1的一个类，它基于陈旧的Dictionary类。而HashMap是Java1.2引进的Map接口的一个实现。 第二，Hashtable是线程安全的，也就是说是线程同步的，而HashMap是线程不安全的。也就是说在单线程环境下应该用HashMap，这样效率更高。 第三，HashMap允许将null值作为key或value，但Hashtable不允许（会抛出NullPointerException）。 3.6 List 和 Map 区别？（数据结构，存储特点）这个要从两个方面来回答，一方面是List和Map的数据结构，另一方面是存储数据的特点。在数据结构方面，List存储的是单列数据的集合，而Map存储的是key、value类型的双列数据集合。在数据存储方面，List存储的数据是有序且可以重复的，而Map中存储的数据是无序且key值不能重复（value值可以重复）。 3.7 List、Map、Set三个接口，存取元素时，各有什么特点？List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去。所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。 Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合（map.keySet()），还可以获得所有的value的结合（map.values()），还可以获得key和value组合成的Map.Entry对象的集合（map.entrySet()）。 List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。 3.8 Collection框架中实现比较要实现什么接口要实现比较有两种方式： 第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，我们称为内部比较器。 第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)。 3.9 ArrayList和LinkedListArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。 3.10 Map集合实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMap HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的 Hashtable Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap 线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMap LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMap TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的； 3.11 map的遍历第一种：KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下： 123456789101112Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext())&#123;Object key = it.next();System.out.println(map.get(key));&#125; 第二种：entrySet（）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下： 1234567891011Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4");//将map集合中的映射关系取出，存入到set集合Iterator it = map.entrySet().iterator();while(it.hasNext())&#123;Entry e =(Entry) it.next();System.out.println("键"+e.getKey () + "的值为" + e.getValue());&#125; 推荐使用第二种方式，即entrySet()方法，效率较高。 对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。 3.11 主要实现类区别小结3.11.1 Vector和ArrayList1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 3.11.3 arraylist和linkedlist1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 3.11.4 HashMap与TreeMap1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 3.11.5 HashTable与HashMap1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。2、HashMap允许存在一个为null的key，多个为null的value 。 3、hashtable的key和value都不允许为null。 3.12 Comparable和Comparator接口是什么？如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。 3.13 Comparable和Comparator接口有何区别？Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。 Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。 3.14 hashcode()的作用，与equal()有什么区别？https://www.cnblogs.com/keyi/p/7119825.html hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出： 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 4、并发4.1 开启一个线程的方法有哪些？销毁一个线程的方法呢？创建线程的最简单的方法就是创建一个实现Runnable 接口的类。Runnable抽象了一个执行代码单元。你可以通过实现Runnable接口的方法创建每一个对象的线程。为实现Runnable 接口，一个类仅需实现一个run()的简单方法 创建线程的另一个途径是创建一个新类来扩展Thread类，然后创建该类的实例。当一个类继承Thread时，它必须重载run()方法 销毁线程：https://blog.csdn.net/qq_37465368/article/details/80869218 （1）设置退出标志，使线程正常退出，也就是当run()方法完成后线程终止 （2）使用interrupt()方法中断线程 （3）使用stop方法强行终止线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和 Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的！） stop()方法太过于暴力，会强行把执行一半的线程终止。这样会就不会保证线程的资源正确释放，通常是没有给与线程完成资源释放工作的机会，因此会导致程序工作在不确定的状态下 4.2 sleep()和wait()的区别？sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 sleep() 和 wait() 的区别就是 调用sleep方法的线程不会释放对象锁，而调用wait() 方法会释放对象锁 ​ 作者：华-山来源：CSDN原文：https://blog.csdn.net/mountain_hua/article/details/82718848版权声明：本文为博主原创文章，转载请附上博文链接！ 4.3 说说进程，线程，协程之间的区别简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 4.4 Thread类中的start()和run()方法有什么区别?start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。 4.5 什么导致线程阻塞阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 方法 说明 sleep() sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止 suspend() 和 resume() 两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程 wait() 和 notify() 两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 4.5 wait(),notify()和suspend(),resume()之间的区别初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。 首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。 其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。 wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。 关于 wait() 和 notify() 方法最后再说明两点：第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。 以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 4.6 产生死锁的条件1.互斥条件：一个资源每次只能被一个进程使用。2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 4.7 怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 4.8 synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁（2）ReentrantLock可以获取各种锁的信息（3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。 4.9 Java当中有哪几种锁 自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 4.10 如何在两个线程间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。 4.11 什么是线程局部变量ThreadLocal和其作用是什么?线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 作用是什么? 简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。 4.12 关于volatile关键字4.12.1 可以创建Volatile数组吗?Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。 4.12.2 volatile能使得一个非原子操作变成原子操作吗?一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 4.12.3 volatile类型变量提供什么保证?volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的。 4.13 Thread类中的yield方法有什么作用？Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。 5、哈希5.1 什么是哈希冲突？比如我们要去买房子，本来已经看好的房子却被商家告知那间房子已经被其他客户买走了。这就是生活中实实在在的冲突问题。 同样的当数据插入到哈希表时，不同key值产生的h(key)却是相等的，这个时候就产生了冲突。这个时候就要解决这个问题。 5.2 怎么解决哈希冲突？ 方法1：拉链法方法2：开地址法 何为拉链法？ 拉链法是解决哈希冲突的一种行之有效的方法，某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。 在拉链（单链表）的哈希表中搜索一个记录是容易的，首先计算哈希地址，然后搜索该地址的单链表。 在插入时应保证表中不含有与该关键字值相同的记录，然后按在有序表中插入一个记录的方法进行。针对关键字值相同的情况，现行的处理方法是更新该关键字值中的内容。 删除关键字值为k的记录，应先在该关键字值的哈希地址处的单链表中找到该记录，然后删除之。 什么是开地址法？ 首先该方法并不建立链表。哈希表由M个元素组成，其地址从0到M-1。我们通过从空表开始，逐个向表中插入新记录的方式建立散列表。插入关键字值为key的新纪录的方法是：从h(key)开始，按照某种规定的次序探查插入新记录的空位置。h(key)被称为基位置。如果h(key)已经被占用，那么需要用一种解决冲突的策略来确定如何探查下一个空位置，所以这种方法又称为空缺编址法。根据不同的解决冲突的策略，可以产生不同的需要被检查的位置序列，称为 探查序列。根据生成的探查序列的不同规则，可以有 线性探查法、伪随机探查法、二次探查法 和 双散列法等开址方法。 线性探查法详解 缺点：线性探查法在情况不好的时候导致许多记录在散列表中连成一片，从而使探查次数增加，影响搜索效率。这种现象称为基本聚集。 线性探查法是一种简单的开地址方法，它使用下列循环探查序列： 1h(key),h(key)+1,...,M-1,0,...,h(key)-1 从基位h(key)开始探查该位置是否被占用，即是否为空位置。如果被占用，则继续探查位置h(key)+1,若该位置也已占用，再根据探查序列中的规定继续检查下一个位置。因此，探查序列为： 1h(i) = (h(x)+i) % M (i=0,1,2,...,M-1) 伪随机法详解 伪随机法是为了消除线性探查的基本聚集而提出来的方法。其基本思想是建立一个伪随机数发生器。当发生冲突时，就利用伪随机数发生器计算下一个探查位置。伪随机数发生器有不同的构造。 一个比较简单的伪随机数产生方法： 12y(0) = h(key)y(i+1) = (y(i)+p) % M (i=0,1,2,...) 式中，y(0)为伪随机数发生器的初值，M为哈希表的长度，P为与M接近的素数 二次探查法详解** 二次探查法也能够消除基本聚集，虽然伪随机数法和二次探查法都能够消除基本聚集。但是如果两个关键字值有相同的基本位置，那么它们就会有相同的探查序列。这是因为伪随机数法和二次探查产生的探查序列是基位置的函数，而不是原来关键字的函数，因此由产生了二次聚集的问题。 双散列法详解 使用双散列方法可以避免二级聚集。双散列法使用两个散列函数，第一个散列函数计算探针序列的起始值，第二个散列函数计算下一个位置的探查步长。 5.3 HashMap是如何扩容的？如何避免扩容？HashMap的自动扩容机制： HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶里都有62500个元素，这时get(),put(),remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小loadFactor后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16\0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置 6、面向对象6.1 什么是多态？多态简单地说“一个接口，多种实现”。多态的出现使得在不同的场合同一个接口能够提供不同功能，具体地说可以让变量、函数或者对象能够提供多种功能。下面是多态的两种类型： 编译时多态 运行时多态 编译时多态主要是对方法进行重载（overload），而运行时多态主要通过使用继承或者实现接口。 什么是运行时多态，也称动态方法分配？ 在 Java 中，运行时多态或动态方法分配是一种在运行过程中的方法重载。在这个过程中，通过调用父类的变量引用被重载的方法。下面是一个例子： 1234567891011121314151617class Car &#123; void run() &#123; System.out.println(“car is running”); &#125;&#125;class Audi extends Car &#123; void run() &#123; System.out.prinltn(“Audi is running safely with 100km”); &#125; public static void main(String args[]) &#123; Car b= new Audi(); ``//向上转型 b.run(); &#125;&#125; 6.2 继承好处： 1：提高了代码的复用性。 2：让类与类之间产生了关系，提供了另一个特征多态的前提。 注意： 子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。 如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 final特点： 1：这个关键字是一个修饰符，可以修饰类，方法，变量。 2：被final修饰的类是一个最终类，不可以被继承。 3：被final修饰的方法是一个最终方法，不可以被覆盖。 4：被final修饰的变量是一个常量，只能赋值一次。 抽象类的特点：** 1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。 2：抽象方法只定义方法声明，并不定义方法实现。 3：抽象类不可以被创建对象(实例化)。 4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 5: 抽象类只能单继承。 抽象类的细节： 1：抽象类中是否有构造函数？ ​ 有，用于给子类对象进行初始化。 2：抽象类中是否可以定义非抽象方法？ ​ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 3：抽象关键字abstract和哪些不可以共存？ ​ final , private , static 4：抽象类中可不可以不定义抽象方法？ ​ 可以。抽象方法目的仅仅为了不让该类创建对象。 6.3 接 口 抽象类和接口的区别：(问的比较多,概念性的问题) 1：抽象类只能被继承，而且只能单继承。 ​ 接口需要被实现，而且可以多实现。 2：抽象类中可以定义非抽象方法，子类可以直接继承使用。 ​ 接口中都有抽象方法，需要子类去实现。 3：抽象类使用的是 is a 关系。 ​ 接口使用的 like a 关系。 4：抽象类的成员修饰符可以自定义。 ​ 接口中的成员修饰符是固定的。全都是public的。 6.4 Java 中的方法重写和方法重载是什么意思? 重载 重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同(即参数个数或类 型不同)。 至于 Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢?这个题目很模糊。如果 几个Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是:如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返 回结果，例如，我们调用 map.remove(key) 方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 Overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不 同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用 重载要注意以下的几点: 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序(当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float) ，但是不能 fun(int,int)) ; 不能通 过访问权限、返回类型、抛出的异常进行重载; 方法的异常类型和数目不会对重载造成影响; 对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的 话，也只是定义了一个新方法，而不会达到重载的效果。 重写 重写 Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调 用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向 对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异 常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的 更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个 全新的方法。 Override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我 们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实 现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。 在覆盖要 注意以下的几点: 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果; 覆盖的方法的返回值必须和被覆盖的方法的返回一致; 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类; 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 6.5 . 什么是 AOP 和 OOP，IOC 和 DI 有什么不同?答: 1)面向对象编程(Object Oriented Programming，OOP，面向对象程序设计)是一种计算机编程架构。AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向切面编程。 将通用需求功能从不 相关类之中分离出来;同时，能够使得很多类共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这 个行为就可以。AOP 就是这种实现分散关注的编程方法，它将“关注”封装在“方面”中 2)控制反转 IOC(Inversion of Control) 控制指的就是程序相关类之间的依赖关系.传统观念设计中,通常由调用者来创建被调用者的实例, 在 Spring里,创建被调用者的工作不再由调用者来完成,而是由 Spring 容器 完成，依赖关系被反转了，称为控制反转，目的是为了获得更好的扩展性和良好的可维护性。依赖注入(Depend ency injection)创建被调用者的工作由 Spring 容器完成，然后注入调用者，因此也称依赖注入。控制反转和依 赖注入是同一个概念。 作者：outSiderYN 链接：https://www.jianshu.com/p/f63b72bf38a7 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 7、基本类型7.1 java中int char,long各占多少字节? 类型 位数 字节数 short 2 16 int 4 32 long 8 64 float 4 32 double 8 64 char 2 16 64位的JVM当中,int的长度是多少? Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 int和Integer的区别 Integer是int的包装类型，在拆箱和装箱中，二者自动转换。int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象。 int 和Integer谁占用的内存更多? Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。 String, StringBuffer和StringBuilder区别 String是字符串常量，final修饰：StringBuffer字符串变量(线程安全)；StringBuilder 字符串变量(线程不安全)。 String和StringBuffer String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。 StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。 但是需要注意现在JVM会对String拼接做一定的优化：String s=“This is only ”+”simple”+”test” 会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。 StringBuffer和StringBuilder StringBuffer是线程安全的可变字符串，其内部实现是可变数组。StringBuilder是jdk 1.5新增的，其功能和StringBuffer类似，但是非线程安全。因此，在没有多线程问题的前提下，使用StringBuilder会取得更好的性能。 8、JVM8.1 垃圾回收算法 标记——清除算法（Mark-Sweep）标记——清除算法是第一种使用和比较完善的垃圾回收算法，算法分为两个过程：1、标记正所有需要回收的对象2、标记完成后清除被标记的对象。其标记的过程就是判断对象有效性，执行可达性分析的过程。其执行流程图大体如何下所示： 同样，我们也借助现实的场景进行描述。图书管里有好多人在看书，图书管理员想要收集起没有被看的书的时候，他决定让所有正在看书的人站起来，然后询问每个人：那一本书是不看的。询问完所有的人之后，同学们做下继续看书。这时候，图书管理员开始寻找所有做过标记的书，把它们收集起来。 缺点：1、每次进行垃圾回收时，会暂停当前用户程序的运行（类似让所有的同学站起来）2、垃圾回收器需要间隔性的检查，并且标记和清除的过程相对较慢。3、在标记清除之后可能会产生大量内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另外一次GC过程。 标记——复制算法（Mark——Copy）标记——复制存储算法通过采用双区域交替使用这种方式解决了标记——清除算法中效率低下的问题。它将可可用内存划分为两个等量的区域（使用区和空闲区），每次只使用一块。当正在使用的区域需要进行垃圾回收时，存活的对象将被复制到另外一块区域。原先被使用的区域被重置，转为空闲区。其执行流程大体如下所示： 图书管理员为了更好的发现不看的书，将图书室一分为二(A区和B区)，同一时刻只有一块区域允许看书。开始时只允许在A区看书。当管理员想要回收A区不被看的书的时候，大喊一嗓子“正在看书的同学拿着你书到B区”。等所有人都到了B区后，图书管理员只要把A区的书收集起来，就完成了任务。下一次收集的时候，则是要求同学带着自己看的书从B区转移到A区。如此循环往复即可。 缺点：1、原有可用空间被缩小为1/2，空间利用率降低了。2、过程中也会暂停当前应用的运行。 标记——整理算法（Mark——Compat）标记-复制算法在对象存活率较高的情况下就要进行较多的复制操作，更重要的是该算法浪费一般的内存空间，为了解决该问题，出现了标记——整理算法：其标记的过程和“标记-清除”算法一样，而整理的过程则是让所有存活的对象都想另外一端移动，然后直接清理掉端边界以外的内存。其执行流程大体如下所示： 缺点：1、暂停当前应用的运行，非实时性的回收。 分代收集算法分代收集算法理论来源于统计学。IBM公司的专门研究发现，对象的生存周期总体可分为三种：新生代、老年代和永久代。因此可以根据各个年代的特点采用适当的垃圾回收算法。比如新生代的对象在每次垃圾时都会有大量的对象死去，只有很少一部分存活，那就可以选择标记-复制算法。另外I，在新生代中每次死亡对象约占98%，那么在标记-复制算法中就不需要按照1：1的比例来划分内存区域，而是将新生代细分为了一块较大的Eden和两块较小的Survivor区域，HotSpot中默认这两块区域的大小比例为8：2。每次新生代可用区域为Eden加上其中一块Survivor区域，共90%的内存空间，这样就只有10%的内存空间处在被闲置状态。在进行垃圾回收时，存活的对象被转移到原本处在“空闲的”Eden区域。如果某次垃圾回收后，存活对象所占空间远大于这10%的内存空间时，也就是Survivor空间不够用时，需要额外的空间来担保，通常是将这些对象转移到老年代。对于老年代来说，大部分对象都处在存活状态。同时，如果一个大对象要在该区域进行分配，而内存空间又不足，那么在没有外部内存空间担保的情况下，就必须选用标记-清除或者标记-整理算法来进行垃圾回收了。 总而言之，分代收集只是根据对象生存周期的不同来选择不同的算法，其本身并没有任何新思想。 增量收集算法以上所述的算法，都存在一个缺点：在进行垃圾回首时需要暂停当前应用的执行，也就是这时候的垃圾回收线程不能和应用线程同时运行。如果我们想做到“在不打断同学们看书的情况下，图书管理员就可以收集没有被看的书”，这也是增量收集算法的目标，即在不中断应用线程的状态下垃圾回收线程也能进行垃圾回收。但是这里需要面对的问题是：垃圾回收线程在标记阶段标记好了，还没来的及清除时，当前应用线程进行内存操作，以至于清除阶段无法正确开展，类似的情况是：图书管理员刚标记了《JAVA核心技术》这本书已经没有人看了，等标记完后，却发现这本书已经有人在看了。 作者：江湖人称小白哥来源：CSDN原文：https://blog.csdn.net/dd864140130/article/details/50084471版权声明：本文为博主原创文章，转载请附上博文链接！ 8.2 简述堆和栈的区别VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 8.3 简述JVM内存分配 基本数据类型比变量和对象的引用都是在栈分配的。 堆内存用来存放由new创建的对象和数组。 类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。 实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自律]]></title>
    <url>%2F2019%2F03%2F05%2F%E8%87%AA%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[扔掉那些写的太满的计划，先从一件小事做起，中途断过也没关系，这不意味着失败 自律不能一步到位​ 所以从今天开始，扔掉那些写的太满的计划，先从一件小事做起，中途断过也没关系，这不意味着失败，做好了就奖励自己，没做好也别自责。当这件事养成习惯以后，你会发现自己可以毫不费力的坚持它了。 你要远离诱惑​ 无论任何时候，你都要主动远离诱惑，就像不要考验人性一样，也不要考验自己的意志力。它们都是禁不起考验的。 自律与你的身体状态有关​ 事实上，你的身体状态，会极大影响你的意志、情绪、智力等等能力。有没有发现，当你没睡够的时候，会变得很容易发脾气，处理工作也容易走神，应该做的事情也不想去做。当我意识到这一点的时候，我就开始非常注意休息，因为只有身体得到良好的休息，才有足够的精力去处理工作。 这里的休息，包括很多方面： 早睡早起 中午小憩，但不会超过30分钟 体育锻炼 周末彻底放下工作，去做一些不消耗太多精力的事情 听音乐]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
