<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F05%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[大家好，我是test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F05%2F13%2Fhello%2F</url>
    <content type="text"><![CDATA[my name is Hellotest]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务控制和数据库相关面试题]]></title>
    <url>%2F2019%2F04%2F15%2F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本部分主要是设计java 事务控制和数据库的部分的核心面试知识，持续更新… 事务相关面试题1.1 ACID原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability） 1.2 spring之事物管理Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。 123456789package org.springframework.transaction;public interface PlatformTransactionManager &#123; //根据TransactionDefinition得到TransactionStatus TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; //根据TransactionDefinition得到TransactionStatus void commit(TransactionStatus status) throws TransactionException; //根据TransactionDefinition得到TransactionStatus void rollback(TransactionStatus status) throws TransactionException;&#125; 1.3 并发事务引起的问题在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。 脏读（Dirty reads）——脏读 发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。 不可重复读（Nonrepeatable read）——不可重复读 发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失 幻读（Phantom read）——幻读 与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。不可重复读与幻读的区别 不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了例如：在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 12con1 = getConnection(); select salary from employee empId ="Mary"; 在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务. 123con2 = getConnection(); update employee set salary = 2000; con2.commit(); 在事务1中，Mary 再次读取自己的工资时，工资变为了2000 12//con1 select salary from employee empId ="Mary"; 在一个事务中前后两次读取的结果并不一致，导致了不可重复读。 幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样例如：目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。 12con1 = getConnection(); Select * from employee where salary =1000; 共读取10条记录 这时另一个事务向employee表插入了一条员工记录，工资也为1000 123con2 = getConnection(); Insert into employee(empId,salary) values("Lili",1000); con2.commit(); 事务1再次读取所有工资为1000的员工 12//con1 select * from employee where salary =1000; 共读取到了11条记录，这就产生了幻像读。 从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。对于前者, 只需要锁住满足条件的记录。对于后者, 要锁住满足条件及其相近的记录。 1.4 几种隔离级别ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 ​ 1.5 事务隔离的实现——锁 共享锁(S锁) 用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。 更新锁(U锁) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。 独占锁(X锁，也叫排他锁) 一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。 Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。 Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。 Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。 Serializable 读加共享锁，写加排他锁，读写互斥。 1.6 Spring支持两种类型的事务管理： 编程式事务管理: 直接使用PlatformTransactionManager实现或使用TransactionTemplate模板类 声明式事务管理: 这意味着你的业务代码将于事务管理分开，只用注解或基于XML配置来管理事务 自从有了基于aop的事务注解，事务的使用变得更简单，相信大家都喜欢这货。够轻、够好用，哪里需要事务只需要一个注解即可，可以在类或者是方法上使用它。确实它足够好用，不过还是有其不足的地方，这个稍后再探讨。我们先看下spring的事务传播行为类型： 事务传播行为类型 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务。如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_REQUIRES_NEW 如果当前没有事务，就新建一个事务。如果当前存在事务，就把当前事务挂起，另建一个事务。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。外套的事务异常可使内嵌事务回滚，反之不会。（底层的数据源必须基于 JDBC 3.0 ，并且实现者需要支持保存点事务机制） PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 readOnly事务属性中的readOnly标志表示对应的事务应该被最优化为只读事务。这是一个最优化提示 。在一些情况下，一些事务策略能够起到显著的最优化效果，例如在使用Object/Relational映射工具（如：Hibernate或TopLink）时避免dirty checking（试图“刷新”）。 Timeout 在事务属性中还有定义“timeout”值的选项，指定事务超时为几秒。在JTA中，这将被简单地传递到J2EE服务器的事务协调程序，并据此得到相应的解释。 1.7 spring 什么情况下进行事务回滚spring事务回滚.默认情况,unchecked异常,即运行时异常runntimeException回滚事务;checked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚. 2 spring2.1 使用Spring框架的好处是什么？ 轻量：Spring 是轻量的，基本的版本大约2MB。 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 容器：Spring 包含并管理应用中对象的生命周期和配置。 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。 2.2 什么是Spring IOC 容器？Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 2.3 IOC的优点是什么？IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。 2.4 依赖注入什么是Spring的依赖注入？ 依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 有哪些不同类型的IOC（依赖注入）方式？ 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 20. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？ 你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 2.5 Spring面向切面编程（AOP）解释AOP 面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。 Aspect 切面 AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 在Spring AOP 中，关注点和横切关注的区别是什么？ 关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 连接点 连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。 通知 通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。 Spring切面可以应用五种类型的通知： before：前置通知，在一个方法执行前被调用。 after: 在方法执行之后调用的通知，无论方法执行是否成功。 after-returning: 仅当方法成功完成后执行的通知。 after-throwing: 在方法抛出异常退出时执行的通知。 around: 在方法执行之前和之后调用的通知。 切点 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 什么是引入? 引入允许我们在已存在的类中增加新的方法和属性。 什么是目标对象? 被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。 什么是代理? 代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 有几种不同类型的自动代理？ BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying 什么是织入。什么是织入应用的不同点？ 织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。 织入可以在编译时，加载时，或运行时完成。 解释基于XML Schema方式的切面实现。 在这种情况下，切面由常规类以及基于XML的配置实现。 解释基于注解的切面实现 在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一 3 数据库3.1 数据库范式第一范式：列不可分，eg:【联系人】（姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF； 第二范式：有主键，保证完全依赖。eg:订单明细表【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName），Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID，不符合2NF； 第三范式：无传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)，eg:订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 3.2 视图是一种基于数据表的一种虚表 （1）视图是一种虚表 （2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表 （3）向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句 （4）视图向用户提供基表数据的另一种表现形式 （5）视图没有存储真正的数据，真正的数据还是存储在基表中 （6）程序员虽然操作的是视图，但最终视图还会转成操作基表 （7）一个基表可以有0个或多个视图 3.2 索引1.什么是索引？何为索引： 数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 2.索引的作用？它的优点缺点是什么？索引作用： 协助快速查询、更新数据库表中数据。 为表设置索引要付出代价的： 一是增加了数据库的存储空间 二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 3.索引的优缺点？ 创建索引可以大大提高系统的性能（优点）： 1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 增加索引也有许多不利的方面(缺点)： 1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 4.哪些列适合建立索引、哪些不适合建索引？索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引： （1）在经常需要搜索的列上，可以加快搜索的速度； （2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； （3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； （4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； （5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； （6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 对于有些列不应该创建索引： （1）对于那些在查询中很少使用或者参考的列不应该创建索引。 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 （2）对于那些只有很少数据值的列也不应该增加索引。 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 （3）对于那些定义为text, image和bit数据类型的列不应该增加索引。 这是因为，这些列的数据量要么相当大，要么取值很少。 (4)当修改性能远远大于检索性能时，不应该创建索引。 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 5.什么样的字段适合建索引唯一、不为空、经常被查询的字段 6.MySQL B+Tree索引和Hash索引的区别?Hash索引和B+树索引的特点： Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位; B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问; 为什么不都用Hash索引而使用B+树索引？ Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样； Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样； Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用； Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据； Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。 补充： 1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。 2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。B+树索引和哈希索引的明显区别是： 3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据； 4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）； 5.哈希索引也不支持多列联合索引的最左匹配规则； 6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。 7.B树和B+树的区别 B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。 B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息) 8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？1.B+的磁盘读写代价更低 B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 2.B+tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 9.聚集索引和非聚集索引区别?聚合索引(clustered index): 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。 非聚合索引(nonclustered index): 非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。 根本区别： 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 3.3.1 索引的特点 （1）索引一旦建立, Oracle管理系统会对其进行自动维护, 而且由Oracle管理系统决定何时使用索引 （2）用户不用在查询语句中指定使用哪个索引 （3）在定义primary key或unique约束后系统自动在相应的列上创建索引 （4）用户也能按自己的需求，对指定单个字段或多个字段，添加索引 需要注意的是：Oracle是自动帮我们管理索引的，并且如果我们指定了primary key或者unique约束，系统会自动在对应的列上创建索引.. 什么时候【不要】创建索引** （1）表经常进行 INSERT/UPDATE/DELETE 操作 （2）表很小(记录超少) （3）列名不经常作为连接条件或出现在 WHERE 子句中 3.3.2 索引优缺点： 索引加快数据库的检索速度 索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引) 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 索引需要占物理和数据空间 3.3.3 索引分类：唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 3.4 什么是临时表，临时表什么时候删除?临时表可以手动删除： 1DROP TEMPORARY TABLE IF EXISTS temp_tb; 临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY， 如： 1234567CREATE TEMPORARY TABLE tmp_table (NAME VARCHAR (10) NOT NULL,time date NOT NULL);select * from tmp_table; 3.5 什么是 内连接、外连接、交叉连接、笛卡尔积等?内连接: 只连接匹配的行 左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 例如1： 1SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b ON a.username=b.username 例如2： 1SELECT a.*,b.* FROM city as a FULL OUTER JOIN user as b ON a.username=b.username 全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 例如： 1SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type 作者：毛里求斯的爱 链接： https://www.nowcoder.com/discuss/135748?type=0&amp;order=0&amp;pos=1&amp;page=1 来源：牛客网 3.6 SQL语言分类SQL语言共分为四大类： 数据查询语言DQL 数据操纵语言DML 数据定义语言DDL 数据控制语言DCL。 1. 数据查询语言DQL 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块： SELECTFROMWHERE 2 .数据操纵语言DML 数据操纵语言DML主要有三种形式： 1) 插入：INSERT 2) 更新：UPDATE 3) 删除：DELETE 3. 数据定义语言DDL 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：CREATE TABLE/VIEW/INDEX/SYN/CLUSTER 表 视图 索引 同义词 簇 DDL操作是隐性提交的！不能rollback 4. 数据控制语言DCL 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如： 1) GRANT：授权。 2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：SQL&gt;ROLLBACK; 3) COMMIT [WORK]：提交。 在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。 (1) 显式提交用COMMIT命令直接完成的提交为显式提交。其格式为：SQL&gt;COMMIT； (2) 隐式提交用SQL命令间接完成的提交为隐式提交。这些命令是：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。 (3) 自动提交若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：SQL&gt;SET AUTOCOMMIT ON；]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题Java整理]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%9D%A2%E8%AF%95%E9%A2%98Java%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本部分主要是设计Java SE 部分的核心面试知识，持续更新… Java面试题整理1、设计模式1.1 简述一下你了解的设计模式。答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 接下来我用一个实例来对代理模式进行更深一步的介绍。a. 实例概况(方法增强) 背景：小成希望买一台最新的顶配Mac电脑冲突：国内还没上，只有美国才有解决方案：寻找代购进行购买代购（代理对象） 代替 我（真实对象） 去买Mac（间接访问的操作） b. 使用步骤步骤1： 创建抽象对象接口（Subject）：声明你（真实对象）需要让代购（代理对象）帮忙做的事（买Mac） 123public interface Subject &#123; public void buyMac();&#125; 步骤2： 创建真实对象类（RealSubject）,即”我“ 123456public class RealSubject implement Subject&#123; @Override public void buyMac() &#123; System.out.println(”买一台Mac“); &#125; &#125; 步骤3： 创建代理对象类（Proxy），即”代购“，并通过代理类创建真实对象实例并访问其方法 12345678910111213141516public class Proxy implements Subject&#123; @Override public void buyMac&#123; //引用并创建真实对象实例，即”我“ RealSubject realSubject = new RealSubject()； //调用真实对象的方法，进行代理购买Mac realSubject.buyMac（）； //代理对象额外做的操作 this.WrapMac()； &#125; public void WrapMac()&#123; System.out.println(”用盒子包装好Mac“); &#125;&#125; 步骤4： 客户端调用 123456public class ProxyPattern &#123; public static void main(String[] args)&#123; Subject proxy = new Proxy()； proxy.buyMac()； &#125;&#125; 结果输出 买一台Mac 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 ​ 适配器模式例子：电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 单例设计模式 解决的问题：保证一个类在内存中的对象唯一性。 比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。 Runtime()**方法就是单例设计模式进行设计的。** 如何保证对象唯一性呢？ 思想： 1，不让其他程序创建该类对象。 2，在本类中创建一个本类对象。 3，对外提供方法，让其他程序获取这个对象。 步骤： 1、因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象； 2、就在类中创建一个本类的对象； 3、定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控） 代码体现： 1，私有化构造函数； 2，创建私有并静态的本类对象； 3，定义公有并静态的方法，返回该对象。 123456789//饿汉式class Single&#123; private Single()&#123;&#125; //**私有化构造函数。** private static Single s = new Single(); //**创建私有并静态的本类对象。** public static Single getInstance()&#123; //**定义公有并静态的方法，返回该对象。** return s; &#125;&#125; 1234567891011//懒汉式:延迟加载方式。class Single2&#123; private Single2()&#123;&#125; private static Single2 s = null; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 1.2 在Java中，什么时候用重载，什么时候用重写？对有经验的Java设计师来说，这是一个相当简单的问题。如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在Java中，重载的方法签名不同，而重写并不是。 1.3 你可以说出几个在JDK库中使用的设计模式吗？装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于Swing和很多的事件监听中。 1.4 MVC是什么？MVC是Model-View-Controller(模型-视图-控制器)的缩写，是一种混合设计模式。用到这种设计模式时，我们所创建的对象要分为：Model 对象，View对象和Controller对象。 归类依据是： Model对象：负责存储数据以及定义如何操作这些数据。 View对象：负责展示而且允许用户编辑来自应用程序的Model对象，View对象用来构建用户界面，与用户交互。 Controller对象：是Model对象与View对象的中间人，负责传递数据，监听各种事件，管理其他对象的生命周期等。 图片来自《iOS编程》(第4版)，作者：【美】Christian Keur Aaron HillegassJoe Conway 上图显示的是应用程序响应用户操作的一个流程。 打个比方：Controller对象好像是一家销售公司，Model对象是产品提供者，View对象是销售人员。公司卖什么，销售人员不用管，销售人员是谁，产品提供者也无需管，公司管要卖什么，管让哪个销售人员去卖。这样一来，各个部分都做自己最擅长的事情，出问题了直接找对应环节，避免了混乱。产品提供者也可以提供产品给其他公司，销售人员换个公司照样能做销售，公司也可以找其他产品提供者，聘用其他销售人员，互相都弱依赖，谁离了谁都能活（当然了，这只是一种理想状态，现实生活中有很多离开了某某某就失业就破产的人和公司）。 再看MVC设计模式，Model对象负责数据，很显然，这里的数据不仅仅可以用于某一个应用，View对象也可以直接拿到其他应用中去，Controller对象就更不用说了。实际上，苹果就是这样封装的：比如UIButton，封装了ImageView和Lable，ImageView显示什么图片，Lable显示什么文字，这些不用UIButton管，它只知道自己可以显示一张图片和一段文字以及与用户交互，其他的交给外界，你给啥图片我显示什么图片，你给啥文字我显示什么文字。这样，UIButton才可以重复使用。 综上，MVC设计模式解决了对象间耦合问题，使得程序易于复用、扩展和变更。 作者：习吾学 链接：https://www.jianshu.com/p/254e2478a4ca 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 2、接口问题2.1 举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？这是很常用但又是很难回答的设计面试问题。接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题： 在Java中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。 接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable等等，因此当你使用抽象类来表示行为时，你的类就不能同时是Runnable和Clonable(译者注：这里的意思是指如果把Runnable等实现为抽象类的情况)，因为在Java中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。 在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。 如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。 3、集合框架3.1 集合与数组数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。 集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。 3.2 层次关系如图所示：图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口 Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。 Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：1.hasNext()是否还有下一个元素。2.next()返回下一个元素。3.remove()删除当前元素。 3.3 几种重要的接口和类简介1、List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 2、Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 3、Map（键值对、键唯一、值不唯一） Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 作者：心诚则灵–艾来源：CSDN原文：https://blog.csdn.net/u010775025/article/details/79315361版权声明：本文为博主原创文章，转载请附上博文链接！ 3.4 ArrayList和Vector的区别（是否有序、是否重复、数据结构、底层实现）ArrayList和Vector都实现了List接口，他们都是有序集合，并且存放的元素是允许重复的。它们的底层都是通过数组来实现的，因此列表这种数据结构检索数据速度快，但增删改速度慢。 而ArrayList和Vector的区别主要在两个方面： 第一，线程安全。Vector是线程安全的，而ArrayList是线程不安全的。因此在如果集合数据只有单线程访问，那么使用ArrayList可以提高效率。而如果有多线程访问你的集合数据，那么就必须要用Vector，因为要保证数据安全。 第二，数据增长。ArrayList和Vector都有一个初始的容量大小，当存储进它们里面的元素超过了容量时，就需要增加它们的存储容量。ArrayList每次增长原来的0.5倍，而Vector增长原来的一倍。ArrayList和Vector都可以设置初始空间的大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 3.5 HashMap和Hashtable的区别HashMap和Hashtable都实现了Map接口，并且都是key-value的数据结构。它们的不同点主要在三个方面： 第一，Hashtable是Java1.1的一个类，它基于陈旧的Dictionary类。而HashMap是Java1.2引进的Map接口的一个实现。 第二，Hashtable是线程安全的，也就是说是线程同步的，而HashMap是线程不安全的。也就是说在单线程环境下应该用HashMap，这样效率更高。 第三，HashMap允许将null值作为key或value，但Hashtable不允许（会抛出NullPointerException）。 3.6 List 和 Map 区别？（数据结构，存储特点）这个要从两个方面来回答，一方面是List和Map的数据结构，另一方面是存储数据的特点。在数据结构方面，List存储的是单列数据的集合，而Map存储的是key、value类型的双列数据集合。在数据存储方面，List存储的数据是有序且可以重复的，而Map中存储的数据是无序且key值不能重复（value值可以重复）。 3.7 List、Map、Set三个接口，存取元素时，各有什么特点？List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去。所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。 List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。 Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合（map.keySet()），还可以获得所有的value的结合（map.values()），还可以获得key和value组合成的Map.Entry对象的集合（map.entrySet()）。 List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。 3.8 Collection框架中实现比较要实现什么接口要实现比较有两种方式： 第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，我们称为内部比较器。 第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)。 3.9 ArrayList和LinkedListArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。 3.10 Map集合实现类：HashMap、Hashtable、LinkedHashMap和TreeMap HashMap HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的 Hashtable Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 ConcurrentHashMap 线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 LinkedHashMap LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。 TreeMap TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的； 3.11 map的遍历第一种：KeySet()将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。典型用法如下： 123456789101112Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4"); //先获取map集合的所有键的set集合，keyset（）Iterator it = map.keySet().iterator(); //获取迭代器while(it.hasNext())&#123;Object key = it.next();System.out.println(map.get(key));&#125; 第二种：entrySet（）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。典型用法如下： 1234567891011Map map = new HashMap();map.put("key1","lisi1");map.put("key2","lisi2");map.put("key3","lisi3");map.put("key4","lisi4");//将map集合中的映射关系取出，存入到set集合Iterator it = map.entrySet().iterator();while(it.hasNext())&#123;Entry e =(Entry) it.next();System.out.println("键"+e.getKey () + "的值为" + e.getValue());&#125; 推荐使用第二种方式，即entrySet()方法，效率较高。 对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。 3.11 主要实现类区别小结3.11.1 Vector和ArrayList1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。 3.11.3 arraylist和linkedlist1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 3.11.4 HashMap与TreeMap1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。同样做测试：在HashMap中，同样的值的map,顺序不同，equals时，false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 3.11.5 HashTable与HashMap1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。2、HashMap允许存在一个为null的key，多个为null的value 。 3、hashtable的key和value都不允许为null。 3.12 Comparable和Comparator接口是什么？如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。 3.13 Comparable和Comparator接口有何区别？Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。 Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。 3.14 hashcode()的作用，与equal()有什么区别？https://www.cnblogs.com/keyi/p/7119825.html hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出： 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 4、并发4.1 开启一个线程的方法有哪些？销毁一个线程的方法呢？创建线程的最简单的方法就是创建一个实现Runnable 接口的类。Runnable抽象了一个执行代码单元。你可以通过实现Runnable接口的方法创建每一个对象的线程。为实现Runnable 接口，一个类仅需实现一个run()的简单方法 创建线程的另一个途径是创建一个新类来扩展Thread类，然后创建该类的实例。当一个类继承Thread时，它必须重载run()方法 销毁线程：https://blog.csdn.net/qq_37465368/article/details/80869218 （1）设置退出标志，使线程正常退出，也就是当run()方法完成后线程终止 （2）使用interrupt()方法中断线程 （3）使用stop方法强行终止线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和 Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的！） stop()方法太过于暴力，会强行把执行一半的线程终止。这样会就不会保证线程的资源正确释放，通常是没有给与线程完成资源释放工作的机会，因此会导致程序工作在不确定的状态下 4.2 sleep()和wait()的区别？sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 sleep() 和 wait() 的区别就是 调用sleep方法的线程不会释放对象锁，而调用wait() 方法会释放对象锁 ​ 作者：华-山来源：CSDN原文：https://blog.csdn.net/mountain_hua/article/details/82718848版权声明：本文为博主原创文章，转载请附上博文链接！ 4.3 说说进程，线程，协程之间的区别简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 4.4 Thread类中的start()和run()方法有什么区别?start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。 4.5 什么导致线程阻塞阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 方法 说明 sleep() sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止 suspend() 和 resume() 两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程 wait() 和 notify() 两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 4.5 wait(),notify()和suspend(),resume()之间的区别初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。 首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。 其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。 wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。 关于 wait() 和 notify() 方法最后再说明两点：第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。 以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 4.6 产生死锁的条件1.互斥条件：一个资源每次只能被一个进程使用。2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 4.7 怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 4.8 synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁（2）ReentrantLock可以获取各种锁的信息（3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。 4.9 Java当中有哪几种锁 自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 4.10 如何在两个线程间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。 4.11 什么是线程局部变量ThreadLocal和其作用是什么?线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 作用是什么? 简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。 4.12 关于volatile关键字4.12.1 可以创建Volatile数组吗?Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。 4.12.2 volatile能使得一个非原子操作变成原子操作吗?一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 4.12.3 volatile类型变量提供什么保证?volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的。 4.13 Thread类中的yield方法有什么作用？Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。 5、哈希5.1 什么是哈希冲突？比如我们要去买房子，本来已经看好的房子却被商家告知那间房子已经被其他客户买走了。这就是生活中实实在在的冲突问题。 同样的当数据插入到哈希表时，不同key值产生的h(key)却是相等的，这个时候就产生了冲突。这个时候就要解决这个问题。 5.2 怎么解决哈希冲突？ 方法1：拉链法方法2：开地址法 何为拉链法？ 拉链法是解决哈希冲突的一种行之有效的方法，某些哈希地址可以被多个关键字值共享，这样可以针对每个哈希地址建立一个单链表。 在拉链（单链表）的哈希表中搜索一个记录是容易的，首先计算哈希地址，然后搜索该地址的单链表。 在插入时应保证表中不含有与该关键字值相同的记录，然后按在有序表中插入一个记录的方法进行。针对关键字值相同的情况，现行的处理方法是更新该关键字值中的内容。 删除关键字值为k的记录，应先在该关键字值的哈希地址处的单链表中找到该记录，然后删除之。 什么是开地址法？ 首先该方法并不建立链表。哈希表由M个元素组成，其地址从0到M-1。我们通过从空表开始，逐个向表中插入新记录的方式建立散列表。插入关键字值为key的新纪录的方法是：从h(key)开始，按照某种规定的次序探查插入新记录的空位置。h(key)被称为基位置。如果h(key)已经被占用，那么需要用一种解决冲突的策略来确定如何探查下一个空位置，所以这种方法又称为空缺编址法。根据不同的解决冲突的策略，可以产生不同的需要被检查的位置序列，称为 探查序列。根据生成的探查序列的不同规则，可以有 线性探查法、伪随机探查法、二次探查法 和 双散列法等开址方法。 线性探查法详解 缺点：线性探查法在情况不好的时候导致许多记录在散列表中连成一片，从而使探查次数增加，影响搜索效率。这种现象称为基本聚集。 线性探查法是一种简单的开地址方法，它使用下列循环探查序列： 1h(key),h(key)+1,...,M-1,0,...,h(key)-1 从基位h(key)开始探查该位置是否被占用，即是否为空位置。如果被占用，则继续探查位置h(key)+1,若该位置也已占用，再根据探查序列中的规定继续检查下一个位置。因此，探查序列为： 1h(i) = (h(x)+i) % M (i=0,1,2,...,M-1) 伪随机法详解 伪随机法是为了消除线性探查的基本聚集而提出来的方法。其基本思想是建立一个伪随机数发生器。当发生冲突时，就利用伪随机数发生器计算下一个探查位置。伪随机数发生器有不同的构造。 一个比较简单的伪随机数产生方法： 12y(0) = h(key)y(i+1) = (y(i)+p) % M (i=0,1,2,...) 式中，y(0)为伪随机数发生器的初值，M为哈希表的长度，P为与M接近的素数 二次探查法详解** 二次探查法也能够消除基本聚集，虽然伪随机数法和二次探查法都能够消除基本聚集。但是如果两个关键字值有相同的基本位置，那么它们就会有相同的探查序列。这是因为伪随机数法和二次探查产生的探查序列是基位置的函数，而不是原来关键字的函数，因此由产生了二次聚集的问题。 双散列法详解 使用双散列方法可以避免二级聚集。双散列法使用两个散列函数，第一个散列函数计算探针序列的起始值，第二个散列函数计算下一个位置的探查步长。 5.3 HashMap是如何扩容的？如何避免扩容？HashMap的自动扩容机制： HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶里都有62500个元素，这时get(),put(),remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小loadFactor后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16\0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置 6、面向对象6.1 什么是多态？多态简单地说“一个接口，多种实现”。多态的出现使得在不同的场合同一个接口能够提供不同功能，具体地说可以让变量、函数或者对象能够提供多种功能。下面是多态的两种类型： 编译时多态 运行时多态 编译时多态主要是对方法进行重载（overload），而运行时多态主要通过使用继承或者实现接口。 什么是运行时多态，也称动态方法分配？ 在 Java 中，运行时多态或动态方法分配是一种在运行过程中的方法重载。在这个过程中，通过调用父类的变量引用被重载的方法。下面是一个例子： 1234567891011121314151617class Car &#123; void run() &#123; System.out.println(“car is running”); &#125;&#125;class Audi extends Car &#123; void run() &#123; System.out.prinltn(“Audi is running safely with 100km”); &#125; public static void main(String args[]) &#123; Car b= new Audi(); ``//向上转型 b.run(); &#125;&#125; 6.2 继承好处： 1：提高了代码的复用性。 2：让类与类之间产生了关系，提供了另一个特征多态的前提。 注意： 子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。 如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 final特点： 1：这个关键字是一个修饰符，可以修饰类，方法，变量。 2：被final修饰的类是一个最终类，不可以被继承。 3：被final修饰的方法是一个最终方法，不可以被覆盖。 4：被final修饰的变量是一个常量，只能赋值一次。 抽象类的特点：** 1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。 2：抽象方法只定义方法声明，并不定义方法实现。 3：抽象类不可以被创建对象(实例化)。 4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 5: 抽象类只能单继承。 抽象类的细节： 1：抽象类中是否有构造函数？ ​ 有，用于给子类对象进行初始化。 2：抽象类中是否可以定义非抽象方法？ ​ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 3：抽象关键字abstract和哪些不可以共存？ ​ final , private , static 4：抽象类中可不可以不定义抽象方法？ ​ 可以。抽象方法目的仅仅为了不让该类创建对象。 6.3 接 口 抽象类和接口的区别：(问的比较多,概念性的问题) 1：抽象类只能被继承，而且只能单继承。 ​ 接口需要被实现，而且可以多实现。 2：抽象类中可以定义非抽象方法，子类可以直接继承使用。 ​ 接口中都有抽象方法，需要子类去实现。 3：抽象类使用的是 is a 关系。 ​ 接口使用的 like a 关系。 4：抽象类的成员修饰符可以自定义。 ​ 接口中的成员修饰符是固定的。全都是public的。 6.4 Java 中的方法重写和方法重载是什么意思? 重载 重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同(即参数个数或类 型不同)。 至于 Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢?这个题目很模糊。如果 几个Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是:如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返 回结果，例如，我们调用 map.remove(key) 方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 Overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不 同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用 重载要注意以下的几点: 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序(当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float) ，但是不能 fun(int,int)) ; 不能通 过访问权限、返回类型、抛出的异常进行重载; 方法的异常类型和数目不会对重载造成影响; 对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的 话，也只是定义了一个新方法，而不会达到重载的效果。 重写 重写 Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调 用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向 对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异 常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的 更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个 全新的方法。 Override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我 们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实 现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。 在覆盖要 注意以下的几点: 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果; 覆盖的方法的返回值必须和被覆盖的方法的返回一致; 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类; 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 6.5 . 什么是 AOP 和 OOP，IOC 和 DI 有什么不同?答: 1)面向对象编程(Object Oriented Programming，OOP，面向对象程序设计)是一种计算机编程架构。AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向切面编程。 将通用需求功能从不 相关类之中分离出来;同时，能够使得很多类共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这 个行为就可以。AOP 就是这种实现分散关注的编程方法，它将“关注”封装在“方面”中 2)控制反转 IOC(Inversion of Control) 控制指的就是程序相关类之间的依赖关系.传统观念设计中,通常由调用者来创建被调用者的实例, 在 Spring里,创建被调用者的工作不再由调用者来完成,而是由 Spring 容器 完成，依赖关系被反转了，称为控制反转，目的是为了获得更好的扩展性和良好的可维护性。依赖注入(Depend ency injection)创建被调用者的工作由 Spring 容器完成，然后注入调用者，因此也称依赖注入。控制反转和依 赖注入是同一个概念。 作者：outSiderYN 链接：https://www.jianshu.com/p/f63b72bf38a7 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 7、基本类型7.1 java中int char,long各占多少字节? 类型 位数 字节数 short 2 16 int 4 32 long 8 64 float 4 32 double 8 64 char 2 16 64位的JVM当中,int的长度是多少? Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 int和Integer的区别 Integer是int的包装类型，在拆箱和装箱中，二者自动转换。int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象。 int 和Integer谁占用的内存更多? Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。 String, StringBuffer和StringBuilder区别 String是字符串常量，final修饰：StringBuffer字符串变量(线程安全)；StringBuilder 字符串变量(线程不安全)。 String和StringBuffer String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。 StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。 但是需要注意现在JVM会对String拼接做一定的优化：String s=“This is only ”+”simple”+”test” 会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。 StringBuffer和StringBuilder StringBuffer是线程安全的可变字符串，其内部实现是可变数组。StringBuilder是jdk 1.5新增的，其功能和StringBuffer类似，但是非线程安全。因此，在没有多线程问题的前提下，使用StringBuilder会取得更好的性能。 8、JVM8.1 垃圾回收算法 标记——清除算法（Mark-Sweep）标记——清除算法是第一种使用和比较完善的垃圾回收算法，算法分为两个过程：1、标记正所有需要回收的对象2、标记完成后清除被标记的对象。其标记的过程就是判断对象有效性，执行可达性分析的过程。其执行流程图大体如何下所示： 同样，我们也借助现实的场景进行描述。图书管里有好多人在看书，图书管理员想要收集起没有被看的书的时候，他决定让所有正在看书的人站起来，然后询问每个人：那一本书是不看的。询问完所有的人之后，同学们做下继续看书。这时候，图书管理员开始寻找所有做过标记的书，把它们收集起来。 缺点：1、每次进行垃圾回收时，会暂停当前用户程序的运行（类似让所有的同学站起来）2、垃圾回收器需要间隔性的检查，并且标记和清除的过程相对较慢。3、在标记清除之后可能会产生大量内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另外一次GC过程。 标记——复制算法（Mark——Copy）标记——复制存储算法通过采用双区域交替使用这种方式解决了标记——清除算法中效率低下的问题。它将可可用内存划分为两个等量的区域（使用区和空闲区），每次只使用一块。当正在使用的区域需要进行垃圾回收时，存活的对象将被复制到另外一块区域。原先被使用的区域被重置，转为空闲区。其执行流程大体如下所示： 图书管理员为了更好的发现不看的书，将图书室一分为二(A区和B区)，同一时刻只有一块区域允许看书。开始时只允许在A区看书。当管理员想要回收A区不被看的书的时候，大喊一嗓子“正在看书的同学拿着你书到B区”。等所有人都到了B区后，图书管理员只要把A区的书收集起来，就完成了任务。下一次收集的时候，则是要求同学带着自己看的书从B区转移到A区。如此循环往复即可。 缺点：1、原有可用空间被缩小为1/2，空间利用率降低了。2、过程中也会暂停当前应用的运行。 标记——整理算法（Mark——Compat）标记-复制算法在对象存活率较高的情况下就要进行较多的复制操作，更重要的是该算法浪费一般的内存空间，为了解决该问题，出现了标记——整理算法：其标记的过程和“标记-清除”算法一样，而整理的过程则是让所有存活的对象都想另外一端移动，然后直接清理掉端边界以外的内存。其执行流程大体如下所示： 缺点：1、暂停当前应用的运行，非实时性的回收。 分代收集算法分代收集算法理论来源于统计学。IBM公司的专门研究发现，对象的生存周期总体可分为三种：新生代、老年代和永久代。因此可以根据各个年代的特点采用适当的垃圾回收算法。比如新生代的对象在每次垃圾时都会有大量的对象死去，只有很少一部分存活，那就可以选择标记-复制算法。另外I，在新生代中每次死亡对象约占98%，那么在标记-复制算法中就不需要按照1：1的比例来划分内存区域，而是将新生代细分为了一块较大的Eden和两块较小的Survivor区域，HotSpot中默认这两块区域的大小比例为8：2。每次新生代可用区域为Eden加上其中一块Survivor区域，共90%的内存空间，这样就只有10%的内存空间处在被闲置状态。在进行垃圾回收时，存活的对象被转移到原本处在“空闲的”Eden区域。如果某次垃圾回收后，存活对象所占空间远大于这10%的内存空间时，也就是Survivor空间不够用时，需要额外的空间来担保，通常是将这些对象转移到老年代。对于老年代来说，大部分对象都处在存活状态。同时，如果一个大对象要在该区域进行分配，而内存空间又不足，那么在没有外部内存空间担保的情况下，就必须选用标记-清除或者标记-整理算法来进行垃圾回收了。 总而言之，分代收集只是根据对象生存周期的不同来选择不同的算法，其本身并没有任何新思想。 增量收集算法以上所述的算法，都存在一个缺点：在进行垃圾回首时需要暂停当前应用的执行，也就是这时候的垃圾回收线程不能和应用线程同时运行。如果我们想做到“在不打断同学们看书的情况下，图书管理员就可以收集没有被看的书”，这也是增量收集算法的目标，即在不中断应用线程的状态下垃圾回收线程也能进行垃圾回收。但是这里需要面对的问题是：垃圾回收线程在标记阶段标记好了，还没来的及清除时，当前应用线程进行内存操作，以至于清除阶段无法正确开展，类似的情况是：图书管理员刚标记了《JAVA核心技术》这本书已经没有人看了，等标记完后，却发现这本书已经有人在看了。 作者：江湖人称小白哥来源：CSDN原文：https://blog.csdn.net/dd864140130/article/details/50084471版权声明：本文为博主原创文章，转载请附上博文链接！ 8.2 简述堆和栈的区别VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 8.3 简述JVM内存分配 基本数据类型比变量和对象的引用都是在栈分配的。 堆内存用来存放由new创建的对象和数组。 类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。 实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自律]]></title>
    <url>%2F2019%2F03%2F05%2F%E8%87%AA%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[扔掉那些写的太满的计划，先从一件小事做起，中途断过也没关系，这不意味着失败 自律不能一步到位​ 所以从今天开始，扔掉那些写的太满的计划，先从一件小事做起，中途断过也没关系，这不意味着失败，做好了就奖励自己，没做好也别自责。当这件事养成习惯以后，你会发现自己可以毫不费力的坚持它了。 你要远离诱惑​ 无论任何时候，你都要主动远离诱惑，就像不要考验人性一样，也不要考验自己的意志力。它们都是禁不起考验的。 自律与你的身体状态有关​ 事实上，你的身体状态，会极大影响你的意志、情绪、智力等等能力。有没有发现，当你没睡够的时候，会变得很容易发脾气，处理工作也容易走神，应该做的事情也不想去做。当我意识到这一点的时候，我就开始非常注意休息，因为只有身体得到良好的休息，才有足够的精力去处理工作。 这里的休息，包括很多方面： 早睡早起 中午小憩，但不会超过30分钟 体育锻炼 周末彻底放下工作，去做一些不消耗太多精力的事情 听音乐]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
